Grafted Stubs|2

Applications remember the most common responses for the most common situations by remote applications, and when they are unavailable, they emulate the expected response, prompting users to proceed with the emulated data or wait for the real data.

Given the scale of dependencies between different applications within most Telcos, applications are usually designed and built using coordinated release cycles which typically produce anywhere between 2 to 12 releases a year. Changes between all of the applications are coordinated to ensure all dependencies are respected and existing functionality is not compromised with new changes. The stability of the collective base of applications serving existing business needs tends to take priority over the realization of new business value. Any new business that risks to destabilize the existing base tends to be deprioritized until those risks are removed. In some Telcos, the schedules for the releases are rigourously maintained and release cycles are treated more like public transport schedules, where all new initiatives have milestones they have to achieve by fixed dates if they are going to be part of the release cycle ("the train always leaves whether you are on it or not"). In other Telcos, the schedules tend to be more flexible, where a certain threshold of business critical initiatives have to be on board before the release date is planned ("the train leaves when there are a minimum number of passengers on board"). Most integrations are performed using a common integration layer, and the team that manages this integration usually has the highest influence on the release schedules. Business divisions that require greater responsiveness in release cycles, and have the organizational influence to bypass the technology department's regulations, tend to build isolated applications that bypass the common integration layer, and synchronize data with other applications through alternate integration strategies like batch integrations. As these applications were conceived and originally realized without the involvment of the technology department, they tend to operate on the fringes of the organization with labels like "Shadow IT". This results in some applications being well integrated but slow to change, and some other appilcations that are poorly integrated but can be changed more rapidly. Inconsistencies in data are common, which ultimately create poor customer experiences.

Therefore realize and launch applications in complete isolation from other applications, where the expected responses for the most common situations are emulated by localized application components that respond as the remote application would be likely to respond. Acting much like an stub that has been grafted on to a tree, all requests to remote applications are routed through them. When applications are coupled to each other, these grafted stubs, one for each type of request, receive requests from the main application, and then route them to the right application for a response. All responses are then received by these grafted stubs and sent to the main application. For each request with specific sets of ordered values, the grafted stubs remembers the variety of responses sent by the remote application, building up a residue of the most common response for each situation. When the remote application is unavailable, the main application can use a residual response for the most common response usually sent by the remote application. End-users who use the grafted information are prompted that the real data from the remote application is unavailable, and this is the expected response. Users can judge the risks of using the information, and decide whether they want to proceed with the grafted information or wait for the real information from the unavailable application. If the grafted information is utilized, the user interface of the main application clearly indicates the compromise. In addition, the grafted appendage remembers the usage of grafted information, and when the unavailable application is finally available, the data from the real application is reconciled with the expected response provided earlier to the end-user. If grafted information is equivalent to the real information, the user interface has a subtle change to indicate that the reconciliation with the remote application was successful. If the information does not reconcile, users are prompted about the differences, where they can choose to go back and reprocess the situation with the real data. All choices, events, requests, grafted responses, and real respones are remembered for retrospective sensemaking or auditing. The grafted stubs also maintain statistics on all request and responses, so analytics can be performed from the entire collection of grafted stubs to infer patterns of communications between applications.
